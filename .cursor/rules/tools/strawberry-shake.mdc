---
description: 
globs: 
alwaysApply: false
---
---
description: This guide outlines the steps and rules for working with StrawberryShake v15 in a .NET project. Follow these instructions to properly manage generated code, interfaces, methods, and the relationship between your GraphQL files and the generated client code.
globs: *.cs, *.razor, *.razor.cs
---
# StrawberryShake v15 Usage Guide for AI


## 1. Code Generation and File Structure

1. **Generated Code Location**  
   - **Rule:** All client code generated by StrawberryShake v15 is located in the `/obj` folder.
   - **Instructions:**  
     - Inspect generated classes by navigating to `/obj/Debug/net{version}/berry` the `{version}` represents the version of dotnet in use, ex: `net9.0` for .NET 9.0.
     - **Do not** modify these files directly; treat them as read-only artifacts generated at build time.

2. **GraphQL Files as the Source of Truth**  
   - **Rule:** Your `.graphql` files define your operations (queries, mutations, fragments) and act as the blueprint for the generated code.
   - **Instructions:**  
     - Ensure each GraphQL operation is well-named and correctly structured.
     - Changes to these files trigger a regeneration of the client code on the next build.
     - The naming convention of generated classes mirrors the names of the GraphQL operations.


## 2. Interfaces and Methods

3. **Interface-Based Programming**  
   - **Rule:** Interact with the generated code via interfaces rather than concrete classes.
   - **Instructions:**  
     - Use interfaces like `IOperation`, `IPageInfo`, etc., which are implemented by the generated types.
     - This practice promotes loose coupling and improves testability.

4. **Using Generated Methods**  
   - **Rule:** Follow the patterns defined by StrawberryShake for executing operations.
   - **Instructions:**  
     - Invoke methods provided by the generated client to execute queries or mutations.
     - Implement proper error handling and null-checking as recommended in the StrawberryShake documentation.
     - Extend functionality through extension methods or partial classes instead of modifying generated code.

## Client Name
- The GraphQL client name for connecting is generated based on the settings in the [.graphqlrc.json](mdc:LegendsCharacterSheet.Client/.graphqlrc.json) file.
- The name is in the extensions.StrawberryShake.name property field. All clients are generated with this name.

## Objects, Records, Interfaces and Classes
### ✅ DO
- Prefer to use the generated record objects
- Generated record objects follow the `[Object]Data` naming schema, for instance, for a `User` object, it would be `UserData`

### ❌ DON'T
- Try to use the GraphQL interfaces directly or build your own object models, records, or classes
- Use object names directly such as `Character` for a character, instead use `CharacterData` from the generated code.


## 3. Project Configuration

5. **Including GraphQL Files in Your Project**  
   - **Rule:** Configure your project file to include GraphQL documents.
   - **Instructions:**  
     - Add the following configuration to your `.csproj` file:
       ```xml
       <ItemGroup>
         <GraphQL Include="GraphQL\*.graphql" />
       </ItemGroup>

       <PropertyGroup>
         <StrawberryShakeVersion>15.0.0</StrawberryShakeVersion>
       </PropertyGroup>
       ```
     - This ensures StrawberryShake locates your GraphQL files and uses the correct version.

6. **Dependency Injection Setup**  
   - **Rule:** Register and inject the StrawberryShake client using .NET’s dependency injection framework.
   - **Instructions:**  
     - Configure the DI container in your `Startup.cs` or `Program.cs` file.
     - Use constructor injection in your services or Blazor components to access the generated client.


## 4. Best Practices and Extensibility

7. **Maintain Separation of Concerns**  
   - **Rule:** Keep generated code separate from custom business logic.
   - **Instructions:**  
     - **Never** directly alter files in the `/obj` folder.
     - Use extension methods or partial classes to add custom functionality without affecting the auto-generated code.

8. **Regularly Rebuild Your Project**  
   - **Rule:** Ensure that any modifications to your GraphQL files are reflected in the generated code.
   - **Instructions:**  
     - Rebuild your project after modifying GraphQL operations to update the generated artifacts.
     - Verify that the new operations and fields appear correctly in the generated classes.

9. **Leverage Official Documentation**  
   - **Rule:** Refer to the official StrawberryShake documentation for advanced configuration and troubleshooting.
   - **Instructions:**  
     - For detailed usage, visit the [StrawberryShake Documentation](mdc:https:/chillicream.com/docs/strawberryshake) at https://chillicream.com/docs/strawberryshake/v15/.
     - When integrating with UI frameworks like MudBlazor, also consult the [MudBlazor Documentation](mdc:https:/mudblazor.com) at https://www.mudblazor.com/docs/overview for responsive UI best practices.

10. **Error Handling and Debugging**  
    - **Rule:** Use built-in error handling and logging provided by StrawberryShake.
    - **Instructions:**  
      - Implement robust error checking around operations.
      - Use build logs and diagnostic tools to troubleshoot any issues related to code generation.

## 5. Registering the Generated DI Components

### Service Registration in Program.cs / Startup.cs

Ensure that your StrawberryShake client—and its associated components—are registered in the dependency injection container. For example, in your Program.cs:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register the generated GraphQL client along with its Blazor components.
builder.Services
       .AddMyGraphQLClient() // Replace with your specific client registration method.
       .AddMyGraphQLComponents(); // Registers DI components from the .Components namespace.

var app = builder.Build();
// ...
```
Note: The AddMyGraphQLComponents() method registers Blazor-specific components (such as query or mutation components) that facilitate UI binding and reactive updates.

### ✅ DO
- Utilize generated Components, such as query and mutation components.

### ❌ DON'T
- Try to use the GraphQL objects directly or build your own clients and components.

### Using DI Components in Blazor Components
Injecting and Utilizing the Components

In your Razor components, inject the required services and generated components. This enables you to call client methods directly or to declaratively execute operations.

#### Example: Injecting and Using a Query Component

```razor
@page "/items"
@using MyProject.GraphQL.Components
@inject IMyGraphQLClient GraphQLClient

<QueryComponent Query="GraphQLClient.GetItems">
    <ChildContent Context="result">
        @if(result.IsLoading)
        {
            <p>Loading...</p>
        }
        else if(result.HasError)
        {
            <p>Error: @result.ErrorMessage</p>
        }
        else
        {
            <ul>
                @foreach(var item in result.Data.Items)
                {
                    <li>@item.Name</li>
                }
            </ul>
        }
    </ChildContent>
</QueryComponent>
```

In this snippet:

QueryComponent: A generated Blazor component that wraps a query execution. It manages the operation’s lifecycle and provides its state (loading, error, data) to the UI.
ChildContent Context: The component passes the result (with properties such as IsLoading, HasError, and Data) so you can bind UI elements accordingly.
3. Combining with MudBlazor for Responsive UI
Integration Tips:

Replace standard HTML elements with MudBlazor components (e.g., MudTable, MudList) for a polished, responsive UI.
Bind the state provided by the DI components to MudBlazor controls for seamless data presentation.
Example: Using a MudBlazor Table

```razor
@using MudBlazor

<QueryComponent Query="GraphQLClient.GetItems">
    <ChildContent Context="result">
        @if(result.IsLoading)
        {
            <MudProgressCircular Indeterminate="true" />
        }
        else if(result.HasError)
        {
            <MudAlert Severity="Severity.Error">@result.ErrorMessage</MudAlert>
        }
        else
        {
            <MudTable Items="result.Data.Items">
                <HeaderContent>
                    <MudTh>Name</MudTh>
                    <MudTh>ID</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Name">@context.Name</MudTd>
                    <MudTd DataLabel="ID">@context.Id</MudTd>
                </RowTemplate>
            </MudTable>
        }
    </ChildContent>
</QueryComponent>
```